---
title: Stack Driver
description: Fan out log entries to multiple destinations using the Stack driver.
---

# Stack Driver

Fan-out a single log to multiple destinations. The Stack driver lets you combine multiple channels (e.g., console, file, webhook) into one logical output so that a single log call is delivered everywhere you need it.

## Overview

- Send each log entry to multiple underlying drivers
- Reference existing channels by name (typed configuration)
- Control failure behavior with `ignoreExceptions`
- Compose with other drivers (e.g., sampling, file rotation, webhooks)
- Great for “critical” or “audit” logs that must land in more than one place

---

## When to use a Stack

- You want critical logs to go to both stdout and a remote collector
- You want a “global” output that includes file rotation and a webhook
- You want a single place to log while deciding fan‑out destinations in config

---

## Fan‑out to multiple outputs (typed configuration)

The recommended approach uses typed channels. Define your base channels (console, file, webhook), then define a Stack channel that fans out to them by referencing their names.

```dart
import 'package:contextual/contextual.dart';

Future<void> main() async {
  final logger = await Logger.create(
    config: LogConfig(
      channels: [
        // Base channels (these can have their own per-channel formatters)
        ConsoleChannel(
          ConsoleOptions(),
          name: 'console',
        ),
        DailyFileChannel(
          DailyFileOptions(path: 'logs/app', retentionDays: 14),
          name: 'file',
        ),
        WebhookChannel(
          WebhookOptions(url: Uri.parse('https://logs.example.com/ingest')),
          name: 'remote',
        ),

        // Stack channel referencing existing channels by name:
        StackChannel(
          StackOptions(
            channels: ['console', 'file', 'remote'],
            ignoreExceptions: true, // see section below
          ),
          name: 'stack',
        ),
      ],
    ),
  );

  // This will go to console, file, and webhook in one call
  logger['stack']?.error('Critical failure', Context({'order_id': 'ord_777'}));
}
```

Notes:
- The `StackOptions.channels` array references other channels by their names.
- Define the base channels first so they’re available to the stack channel.
- Each underlying channel can have its own formatter (e.g., pretty for console, JSON for webhook).

---

## Fan‑out with the imperative API

You can also compose a `StackLogDriver` programmatically. This is handy when wiring dynamically or in tests.

```dart
import 'package:contextual/contextual.dart';

Future<void> main() async {
  final logger = await Logger.create();

  // Add some base channels first
  logger.addChannel('console', ConsoleLogDriver());
  logger.addChannel('file', DailyFileLogDriver.fromOptions(
    DailyFileOptions(path: 'logs/app', retentionDays: 14),
  ));

  // Build a stack by reusing the underlying drivers:
  final consoleDriver = logger.getChannel('console')!.driver;
  final fileDriver = logger.getChannel('file')!.driver;

  logger.addChannel(
    'stack',
    StackLogDriver([consoleDriver, fileDriver], ignoreExceptions: true),
  );

  // Fan-out to both console and file
  logger['stack']?.warning('This is delivered to multiple outputs');
}
```

Tip: Prefer typed configuration for application code; use the imperative API for dynamic wiring, demos, or tests.

---

## Understanding `ignoreExceptions`

- `ignoreExceptions: true` (recommended)
  - If one underlying driver throws, the stack logs to the remaining drivers and continues.
  - Prevents one destination from breaking all logging.

- `ignoreExceptions: false`
  - If an underlying driver throws, the stack will surface the exception.
  - Use when you need failure visibility at the call site and prefer fail‑fast behavior.

Example (typed):

```dart
StackChannel(
  StackOptions(
    channels: ['console', 'file', 'remote'],
    ignoreExceptions: true, // continue even if one fails
  ),
  name: 'stack',
);
```

---

## Targeting and routing

- By name (deliver to everything in the stack):
  ```dart
  logger['stack']?.info('Hello, world!');
  ```

- By underlying driver type (not specific to stack, but useful):
  ```dart
  // Deliver to all console drivers (including those in a stack)
  logger.forDriver<ConsoleLogDriver>().debug('This goes to all console outputs');
  ```

---

## Formatting behavior

- Apply formatters at the underlying channel level:
  - Console: PrettyLogFormatter (dev) or JsonLogFormatter (prod)
  - File: JsonLogFormatter for ingestion, or Pretty/Plain for readability
  - Webhook: JsonLogFormatter (recommended for remote ingestion)
- The Stack driver forwards the log entry; it does not reformat. Each underlying channel uses its own (channel-specific or logger‑global) formatter.

---

## Examples

### 1) Critical logs to all destinations

```dart
final logger = await Logger.create(
  config: LogConfig(
    channels: [
      ConsoleChannel(ConsoleOptions(), name: 'console'),
      DailyFileChannel(DailyFileOptions(path: 'logs/app'), name: 'file'),
      WebhookChannel(
        WebhookOptions(url: Uri.parse('https://logs.example.com/ingest')),
        name: 'remote',
      ),
      StackChannel(
        StackOptions(
          channels: ['console', 'file', 'remote'],
          ignoreExceptions: true,
        ),
        name: 'stack',
      ),
    ],
  ),
);

// Critical messages go everywhere:
logger['stack']?.critical('Database unavailable', Context({'cluster': 'eu-1'}));
```

### 2) Stack + Sampling (reduce noise)

Wrap your stack with a `SamplingChannel` for noisy levels:

```dart
final logger = await Logger.create(
  config: LogConfig(
    channels: [
      ConsoleChannel(ConsoleOptions(), name: 'console'),
      DailyFileChannel(DailyFileOptions(path: 'logs/app'), name: 'file'),
      StackChannel(
        StackOptions(channels: ['console', 'file'], ignoreExceptions: true),
        name: 'stack',
      ),
      // Sample the stack via a separate channel:
      SamplingChannel(
        SamplingOptions(
          rates: {
            Level.debug: 0.1, // keep 10% of debug logs
            Level.info: 1.0,   // keep all info logs
          },
          wrappedChannel: 'stack',
        ),
        name: 'stack_sampled',
      ),
    ],
  ),
);

// Route noisy logs through the sampled stack
logger['stack_sampled']?.debug('This debug log may be sampled');
```

### 3) Per‑destination formatters

```dart
final logger = await Logger.create(
  config: LogConfig(
    channels: [
      ConsoleChannel(
        ConsoleOptions(),
        name: 'console',
        formatter: PrettyLogFormatter(),
      ),
      WebhookChannel(
        WebhookOptions(url: Uri.parse('https://logs.example.com/ingest')),
        name: 'remote',
        formatter: JsonLogFormatter(),
      ),
      StackChannel(
        StackOptions(channels: ['console', 'remote'], ignoreExceptions: true),
        name: 'stack',
      ),
    ],
  ),
);

logger['stack']?.info('One message, two formats');
```

---

## Best practices

- Prefer `ignoreExceptions: true` to avoid one failing destination blocking others.
- Keep your stack simple; too many destinations increase latency and failure surface area.
- Apply formatters per underlying channel to match destination expectations.
- Avoid recursive configurations (e.g., a stack referencing itself).
- For high‑volume logs:
  - Use `SamplingChannel` to reduce noise at lower levels.
  - Pair with `DailyFileChannel` for local durability and retention.
- Always call `await logger.shutdown()` on application exit, especially when file drivers are involved.
- Treat remote endpoints as unreliable; keep a local Console/File fallback readily available.

---

## See also

- API Overview: /api/overview
- Driver Configuration: /api/drivers/configuration.md
- Console Driver (guide): /drivers/console.md
- Daily File Driver (guide): /drivers/daily-file.md
- Webhook Driver (guide): /drivers/webhook.md
- Middleware (advanced): /advanced/middleware.md
- Batching & Shutdown (advanced): /advanced/batching-and-shutdown.md
