---
title: Sampling Driver
description: Reduce log volume by routing messages through probabilistic sampling strategies.
---

# Sampling Driver

Reduce log volume without losing signal. The Sampling driver probabilistically drops logs based on per-level rates and forwards retained logs to another destination. It’s ideal for high‑volume services where debug/info logs can overwhelm storage or network bandwidth.

## Overview

- Wraps another channel/driver and decides whether to forward each log
- Per‑level sampling rates (0.0–1.0) to control volume for each severity
- Works with all other drivers (Console, Daily File, Webhook) and Stack
- Configurable via typed channels or the imperative API

---

## Options

Configure via `SamplingOptions` (used by the typed `SamplingChannel`):

- `rates: Map<Level, double>` (required)
  - Per-level sampling rates (0.0 to 1.0). 1.0 keeps all; 0.0 drops all.
- `wrappedChannel: String` (required)
  - The name of the underlying channel to wrap and forward retained logs to.

Example:

```dart
const options = SamplingOptions(
  rates: {
    Level.debug: 0.1, // keep ~10% of debug logs
    Level.info: 1.0,  // keep all info logs
  },
  wrappedChannel: 'console',
);
```

How it works:
- For each log, the driver evaluates the log `Level` and uses the corresponding rate.
- If the random draw is within the rate, the log is forwarded to `wrappedChannel`.
- Otherwise, the log is dropped.

Tip: Define explicit rates for the levels you care about (e.g., always 1.0 for warnings and errors).

---

## Typed configuration (recommended)

Use typed channels for clarity and compile‑time safety. Define the destination you want to wrap (e.g., `console`), then add a `SamplingChannel` that references it by name.

### Wrap a single destination (console)

```dart
import 'package:contextual/contextual.dart';

Future<void> main() async {
  final logger = await Logger.create(
    config: LogConfig(
      channels: const [
        // Destination to receive kept logs
        ConsoleChannel(
          ConsoleOptions(),
          name: 'console',
        ),

        // Sampled wrapper: routes to the 'console' channel
        SamplingChannel(
          SamplingOptions(
            rates: {
              Level.debug: 0.1, // keep ~10% of debug logs
              Level.info: 1.0,  // keep all info logs
              // define other levels as needed
            },
            wrappedChannel: 'console',
          ),
          name: 'console_sampled',
        ),
      ],
    ),
  );

  // Send noisy logs through the sampled channel:
  logger['console_sampled']?.debug('noisy diagnostic event');
  logger['console_sampled']?.info('operational event');
}
```

### Sample a Stack (fan‑out with volume control)

```dart
final logger = await Logger.create(
  config: LogConfig(
    channels: const [
      ConsoleChannel(ConsoleOptions(), name: 'console'),
      DailyFileChannel(DailyFileOptions(path: 'logs/app'), name: 'file'),

      // Fan-out to both console and file
      StackChannel(
        StackOptions(
          channels: ['console', 'file'],
          ignoreExceptions: true,
        ),
        name: 'stack',
      ),

      // Add a sampled variant of the stack
      SamplingChannel(
        SamplingOptions(
          rates: {
            Level.debug: 0.05, // keep ~5% of debug logs
            Level.info: 0.5,   // keep ~50% of info logs
            Level.warning: 1.0,
            Level.error: 1.0,
            Level.critical: 1.0,
          },
          wrappedChannel: 'stack',
        ),
        name: 'stack_sampled',
      ),
    ],
  ),
);

// Route high-volume logs via the sampled stack:
logger['stack_sampled']?.debug('debug burst event');
```

### Multiple sampled variants per destination

```dart
final logger = await Logger.create(
  config: LogConfig(
    channels: const [
      ConsoleChannel(ConsoleOptions(), name: 'console'),

      // Lossy (aggressive) for very noisy telemetry
      SamplingChannel(
        SamplingOptions(
          rates: { Level.debug: 0.01, Level.info: 0.25 },
          wrappedChannel: 'console',
        ),
        name: 'console_lossy',
      ),

      // Lossless for anything important
      SamplingChannel(
        SamplingOptions(
          rates: { Level.debug: 1.0, Level.info: 1.0 },
          wrappedChannel: 'console',
        ),
        name: 'console_lossless',
      ),
    ],
  ),
);
```

---

## Imperative wiring (raw drivers)

You can also compose the driver programmatically using `SamplingLogDriver` to wrap an existing driver instance.

```dart
import 'package:contextual/contextual.dart';

Future<void> main() async {
  final logger = await Logger.create();

  // Destination to wrap
  logger.addChannel('console', ConsoleLogDriver());

  // Build a sampler that wraps the console driver
  final wrapped = logger.getChannel('console')!.driver;

  final sampler = SamplingLogDriver(
    wrappedDriver: wrapped,
    samplingRates: {
      Level.debug: 0.1,
      Level.info: 1.0,
    },
  );

  logger.addChannel('console_sampled', sampler);

  // Use the sampled channel
  logger['console_sampled']?.debug('noisy event');
}
```

---

## Examples

### Environment‑driven rates

Adjust rates per environment without code changes:

```dart
double _rate(String key, double fallback) {
  // Pseudocode – read from env/flags/config service
  final v = const String.fromEnvironment(key, defaultValue: '');
  return double.tryParse(v) ?? fallback;
}

final logger = await Logger.create(
  config: LogConfig(
    channels: [
      ConsoleChannel(ConsoleOptions(), name: 'console'),
      SamplingChannel(
        SamplingOptions(
          rates: {
            Level.debug: _rate('SAMPLE_DEBUG', 0.05),
            Level.info: _rate('SAMPLE_INFO', 1.0),
            // define others as needed
          },
          wrappedChannel: 'console',
        ),
        name: 'console_sampled',
      ),
    ],
  ),
);
```

### Route by intent

- For high-volume, low-priority logs: route through a sampled channel:
  ```dart
  logger['stack_sampled']?.debug('verbose pipeline event');
  ```

- For important/audit logs: route through the original unsampled channel:
  ```dart
  logger['stack']?.error('order rejected', Context({'order_id': 'ord_123'}));
  ```

---

## Best practices

- Do not sample error/critical levels unless you fully accept data loss for those events.
- Be explicit: define sampling rates for all levels you care about; test the behavior with known distributions.
- Sample at the edge of noise: wrap only the channels or code paths producing high-volume logs.
- Prefer sampling lower-severity levels (debug/info); keep warnings and above at 1.0.
- For audit/compliance logs, avoid sampling and use durable storage (e.g., Daily File).
- Validate end‑to‑end: measure ingestion/storage before and after to confirm reduction and retained signal.
- In tests, set all rates to 1.0 for deterministic assertions.

---

## See also

- [API Overview](/api/overview.mdx)
- [Driver Configuration](configuration.mdx)
- [Console Driver](console.mdx)
- [Daily File Driver](daily-file.mdx)
- [Webhook Driver](webhook.mdx)
- [Stack Driver](stack.mdx)
- [Batching & Shutdown](../../advanced/batching-and-shutdown.mdx)
