"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[236],{850:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"advanced/shelf-integration","title":"Shelf Integration","description":"Capture HTTP request and response logs using Contextual with Shelf applications.","source":"@site/docs/advanced/shelf-integration.mdx","sourceDirName":"advanced","slug":"/advanced/shelf-integration","permalink":"/contextual/advanced/shelf-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/contextual/edit/main/website/docs/advanced/shelf-integration.mdx","tags":[],"version":"current","frontMatter":{"title":"Shelf Integration","description":"Capture HTTP request and response logs using Contextual with Shelf applications."},"sidebar":"docsSidebar","previous":{"title":"Type Formatters & Printers","permalink":"/contextual/advanced/type-formatters"},"next":{"title":"Migration to v2","permalink":"/contextual/migration/v2"}}');var s=t(4848),i=t(8453);const a={title:"Shelf Integration",description:"Capture HTTP request and response logs using Contextual with Shelf applications."},o="Shelf Integration Tips",l={},d=[{value:"Usage",id:"usage",level:2},{value:"Tips",id:"tips",level:2},{value:"Components at a glance",id:"components-at-a-glance",level:2},{value:"Custom log profiles",id:"custom-log-profiles",level:2},{value:"Sanitizing sensitive data",id:"sanitizing-sensitive-data",level:2},{value:"Custom log writers",id:"custom-log-writers",level:2},{value:"Metrics and context enrichment",id:"metrics-and-context-enrichment",level:2},{value:"Testing the middleware",id:"testing-the-middleware",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"shelf-integration-tips",children:"Shelf Integration Tips"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"contextual_shelf"})," package provides an HttpLogger middleware that captures request/response metadata and logs via your configured drivers."]}),"\n",(0,s.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"import 'package:contextual/contextual.dart';\nimport 'package:contextual_shelf/contextual_shelf.dart';\nimport 'package:shelf/shelf.dart';\n\nvoid main() async {\n  final logger = await Logger.create(\n    config: LogConfig(\n      channels: [ConsoleChannel(ConsoleOptions(), name: 'console')],\n    ),\n  );\n\n  final httpLogger = HttpLogger(DefaultLogProfile(), DefaultLogWriter());\n\n  final handler = const Pipeline()\n      .addMiddleware(httpLogger.middleware)\n      .addHandler((req) => Response.ok('ok'));\n\n  // serve ...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"tips",children:"Tips"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Consider a dedicated channel for HTTP logging (e.g., name: ",(0,s.jsx)(n.code,{children:"http"}),"), and target it with ",(0,s.jsx)(n.code,{children:"logger.forDriver<ConsoleLogDriver>('http')"})," when you need driver-specific output."]}),"\n",(0,s.jsxs)(n.li,{children:["Combine with batching via ",(0,s.jsx)(n.code,{children:"LogConfig.batching"})," for high-throughput endpoints."]}),"\n",(0,s.jsx)(n.li,{children:"Add driver middleware to redact sensitive headers or query parameters."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"components-at-a-glance",children:"Components at a glance"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"contextual_shelf"})," is built from three composable pieces:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"HttpLogger"})})," \u2013 the Shelf middleware that measures requests, applies log profiles, and delegates to a writer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"LogProfile"})})," \u2013 decides ",(0,s.jsx)(n.em,{children:"whether"})," a request should be logged."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"LogWriter"})})," \u2013 decides ",(0,s.jsx)(n.em,{children:"how"})," a request is logged, including context payloads, sanitization, and severity."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The defaults (",(0,s.jsx)(n.code,{children:"LogNonGetRequests"})," + ",(0,s.jsx)(n.code,{children:"DefaultLogWriter"}),") work out of the box, but each piece can be swapped independently."]}),"\n",(0,s.jsx)(n.h2,{id:"custom-log-profiles",children:"Custom log profiles"}),"\n",(0,s.jsxs)(n.p,{children:["Implement ",(0,s.jsx)(n.code,{children:"LogProfile"})," to control which requests produce logs. This is useful for sampling static assets or limiting health checks."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class HealthCheckAwareProfile implements LogProfile {\n  const HealthCheckAwareProfile();\n\n  @override\n  bool shouldLogRequest(Request request) {\n    final path = request.url.path;\n    if (path == 'healthz' || path == 'readiness') {\n      return false; // skip noisy probes\n    }\n    if (request.method == 'GET') {\n      // Only log GETs from /api or when explicitly flagged\n      return path.startsWith('api/') ||\n          request.headers['x-log-request'] == 'true';\n    }\n    // Always log mutating verbs\n    return true;\n  }\n}\n\nfinal httpLogger = HttpLogger(\n  const HealthCheckAwareProfile(),\n  DefaultLogWriter(logger),\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Profiles run synchronously during each request, so keep logic fast and side-effect free."}),"\n",(0,s.jsx)(n.h2,{id:"sanitizing-sensitive-data",children:"Sanitizing sensitive data"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DefaultLogWriter"})," includes a lightweight ",(0,s.jsx)(n.code,{children:"Sanitizer"})," (",(0,s.jsx)(n.code,{children:"contextual_shelf/lib/src/sanitizer.dart:1-23"}),") that masks headers and nested maps. Configure the mask and fields to scrub:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final logWriter = DefaultLogWriter(\n  logger,\n  sanitizer: Sanitizer(mask: '[REDACTED]'),\n);\n\n// Extend DefaultLogWriter to choose which headers to hide\nclass PaymentsLogWriter extends DefaultLogWriter {\n  PaymentsLogWriter(Logger logger)\n      : super(logger, sanitizer: Sanitizer(mask: '******'));\n\n  @override\n  void logRequest(\n    Request request,\n    Response response,\n    DateTime start,\n    Duration elapsed, {\n    int? memory,\n    int? pid,\n  }) {\n    super.logRequest(\n      request,\n      response,\n      start,\n      elapsed,\n      memory: memory,\n      pid: pid,\n    );\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To sanitize bodies or query parameters, subclass ",(0,s.jsx)(n.code,{children:"DefaultLogWriter"})," and preprocess ",(0,s.jsx)(n.code,{children:"request.readAsString()"})," or ",(0,s.jsx)(n.code,{children:"request.url.queryParameters"})," before calling ",(0,s.jsx)(n.code,{children:"logger.withContext"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"custom-log-writers",children:"Custom log writers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DefaultLogWriter"})," (",(0,s.jsx)(n.code,{children:"contextual_shelf/lib/src/default_log_writer.dart:6-67"}),") enriches each entry with:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sanitized request and response headers"}),"\n",(0,s.jsx)(n.li,{children:"Request duration in milliseconds"}),"\n",(0,s.jsx)(n.li,{children:"Captured RSS memory and OS process ID (when available)"}),"\n",(0,s.jsx)(n.li,{children:"Optional error details and stack traces"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Create your own ",(0,s.jsx)(n.code,{children:"LogWriter"})," to change severity levels, push structured payloads, or emit multiple log entries per request:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class AuditLogWriter implements LogWriter {\n  AuditLogWriter(this.logger);\n\n  final Logger logger;\n\n  @override\n  void logRequest(\n    Request request,\n    Response response,\n    DateTime start,\n    Duration elapsed, {\n    int? memory,\n    int? pid,\n  }) {\n    final context = Context({\n      'method': request.method,\n      'status': response.statusCode,\n      'duration_ms': elapsed.inMilliseconds,\n      'user': request.headers['x-user-id'],\n    });\n\n    logger.withContext(context).info('HTTP ${request.requestedUri}');\n  }\n\n  @override\n  void logError(\n    Request request,\n    Object error,\n    StackTrace stackTrace,\n    DateTime start,\n    Duration elapsed, {\n    int? memory,\n    int? pid,\n  }) {\n    logger.error('HTTP failure', Context({\n      'error': error.toString(),\n      'stack_trace': stackTrace.toString(),\n      'method': request.method,\n      'path': request.requestedUri.path,\n    }));\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Plug it into the middleware:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"logger.addMiddleware(() => {'service': 'api'});\n\nfinal httpLogger = HttpLogger(\n  const LogNonGetRequests(),\n  AuditLogWriter(logger),\n);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"metrics-and-context-enrichment",children:"Metrics and context enrichment"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"HttpLogger"})," captures elapsed time, memory usage, and process ID (",(0,s.jsx)(n.code,{children:"contextual_shelf/lib/src/http_logger.dart:7-57"}),"). Use channel-specific middlewares or the new ",(0,s.jsx)(n.a,{href:"/advanced/type-formatters",children:"Type Formatters & Printers"})," guide to format these values consistently."]}),"\n",(0,s.jsxs)(n.p,{children:["Tip: register a dedicated channel (e.g., ",(0,s.jsx)(n.code,{children:"http"}),") tied to a JSON formatter and keep application logs separate from request traces."]}),"\n",(0,s.jsx)(n.h2,{id:"testing-the-middleware",children:"Testing the middleware"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Unit test custom profiles by asserting ",(0,s.jsx)(n.code,{children:"shouldLogRequest"})," outputs."]}),"\n",(0,s.jsxs)(n.li,{children:["Use Shelf's ",(0,s.jsx)(n.code,{children:"serveRequests"})," with a test handler to ensure your writer emits the expected context for happy-path and error cases."]}),"\n",(0,s.jsxs)(n.li,{children:["Capture formatted output by adding an in-memory channel during tests (e.g., ",(0,s.jsx)(n.code,{children:"logger.addChannel('memory', TestDriver())"}),")."]}),"\n",(0,s.jsx)(n.li,{children:"For integration suites, point the HTTP channel at a temporary file and assert JSON payloads."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);