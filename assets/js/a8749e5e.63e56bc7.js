"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[661],{1153:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"advanced/type-formatters","title":"Type Formatters & Printers","description":"Customize how Contextual renders specific value types and channel output using LogTypeFormatter and formatter APIs.","source":"@site/docs/advanced/type-formatters.mdx","sourceDirName":"advanced","slug":"/advanced/type-formatters","permalink":"/contextual/advanced/type-formatters","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/contextual/edit/main/website/docs/advanced/type-formatters.mdx","tags":[],"version":"current","frontMatter":{"title":"Type Formatters & Printers","description":"Customize how Contextual renders specific value types and channel output using LogTypeFormatter and formatter APIs."},"sidebar":"docsSidebar","previous":{"title":"Batching and Shutdown","permalink":"/contextual/advanced/batching-and-shutdown"},"next":{"title":"Shelf Integration","permalink":"/contextual/advanced/shelf-integration"}}');var a=n(4848),s=n(8453);const o={title:"Type Formatters & Printers",description:"Customize how Contextual renders specific value types and channel output using LogTypeFormatter and formatter APIs."},i="Custom Type Formatters & Printers",l={},d=[{value:"When to reach for type formatters",id:"when-to-reach-for-type-formatters",level:2},{value:"Registering a formatter",id:"registering-a-formatter",level:2},{value:"Built-in helpers",id:"built-in-helpers",level:2},{value:"Formatting nested and structured data",id:"formatting-nested-and-structured-data",level:2},{value:"Channel-level printers (message formatters)",id:"channel-level-printers-message-formatters",level:2},{value:"Testing and maintenance tips",id:"testing-and-maintenance-tips",level:2},{value:"Next steps",id:"next-steps",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"custom-type-formatters--printers",children:"Custom Type Formatters & Printers"})}),"\n",(0,a.jsx)(t.p,{children:"Contextual resolves the final string that reaches a channel in two steps:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Type formatters"})," (",(0,a.jsx)(t.code,{children:"LogTypeFormatter<T>"}),") convert strongly-typed data objects into strings before they reach a channel formatter."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Channel/message formatters"})," (",(0,a.jsx)(t.code,{children:"LogMessageFormatter"}),") wrap the already formatted message with level, timestamp, context, or any other metadata."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["By combining both layers you can create rich, structured logs without sprinkling ",(0,a.jsx)(t.code,{children:".toString()"})," calls throughout your code."]}),"\n",(0,a.jsx)(t.h2,{id:"when-to-reach-for-type-formatters",children:"When to reach for type formatters"}),"\n",(0,a.jsx)(t.p,{children:"Type formatters are ideal when you frequently log:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Domain objects (orders, users, payloads) that need a consistent representation"}),"\n",(0,a.jsx)(t.li,{children:"Complex collections (maps, lists) that benefit from stable formatting"}),"\n",(0,a.jsx)(t.li,{children:"Errors/exceptions where you want to include stack traces or metadata by default"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Registered formatters are global to the logger instance. The most specific formatter wins, so adding a formatter for ",(0,a.jsx)(t.code,{children:"User"})," does not affect other types."]}),"\n",(0,a.jsx)(t.h2,{id:"registering-a-formatter",children:"Registering a formatter"}),"\n",(0,a.jsxs)(t.p,{children:["Implement ",(0,a.jsx)(t.code,{children:"LogTypeFormatter<T>"})," and register it with ",(0,a.jsx)(t.code,{children:"logger.addTypeFormatter"}),". The formatter receives the log level plus the ambient ",(0,a.jsx)(t.code,{children:"Context"}),", enabling level-aware formatting."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"import 'package:contextual/contextual.dart';\n\nclass UserFormatter extends LogTypeFormatter<User> {\n  const UserFormatter();\n\n  @override\n  String format(Level level, User user, Context context) {\n    final tags = context['tags'];\n    return '[User:${user.id}] ${user.email} tags=$tags';\n  }\n}\n\nfinal logger = await Logger.create(\n  config: const LogConfig(\n    channels: [ConsoleChannel(ConsoleOptions(), name: 'console')],\n  ),\n)\n  ..addTypeFormatter(const UserFormatter());\n\nlogger.info(User(id: '42', email: 'ops@example.com'));\n"})}),"\n",(0,a.jsx)(t.p,{children:"Re-registering with the same type replaces the previous formatter, making overrides straightforward for tests or special environments."}),"\n",(0,a.jsx)(t.h2,{id:"built-in-helpers",children:"Built-in helpers"}),"\n",(0,a.jsxs)(t.p,{children:["Contextual ships with a few reusable formatters under ",(0,a.jsx)(t.code,{children:"contextual/src/type_format/"}),":"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"LevelFormatter"})," \u2013 renders ",(0,a.jsx)(t.code,{children:"Level"})," enums in uppercase."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"MapFormatter"})," \u2013 pretty-prints nested maps and can delegate to other type formatters per value type."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"You can mix and match these with your own formatters:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"logger\n  ..addTypeFormatter(const LevelFormatter())\n  ..addTypeFormatter(MapFormatter(valueFormatters: {\n    DateTime: const IsoDateFormatter(),\n  }));\n\nclass IsoDateFormatter extends LogTypeFormatter<DateTime> {\n  const IsoDateFormatter();\n\n  @override\n  String format(Level level, DateTime value, Context context) {\n    return value.toUtc().toIso8601String();\n  }\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"formatting-nested-and-structured-data",children:"Formatting nested and structured data"}),"\n",(0,a.jsx)(t.p,{children:"Type formatters make it easy to control JSON-like payloads without switching to a JSON formatter globally. For example, you can redact secrets or compress verbose payloads:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"class PaymentFormatter extends LogTypeFormatter<PaymentPayload> {\n  const PaymentFormatter();\n\n  @override\n  String format(Level level, PaymentPayload payload, Context context) {\n    final masked = payload.cardNumber.replaceRange(6, 12, '******');\n    return 'Payment(amount: ${payload.amount}, card: $masked, status: ${payload.status})';\n  }\n}\n\nlogger.addTypeFormatter(const PaymentFormatter());\nlogger.debug(paymentPayload); // Always redacted\n"})}),"\n",(0,a.jsx)(t.p,{children:"Because type formatters run before channel formatters, you still benefit from JSON or pretty formatters downstream."}),"\n",(0,a.jsx)(t.h2,{id:"channel-level-printers-message-formatters",children:"Channel-level printers (message formatters)"}),"\n",(0,a.jsxs)(t.p,{children:["Type formatters solve per-object rendering. To change the ",(0,a.jsx)(t.em,{children:"envelope"})," of each log entry, supply a custom ",(0,a.jsx)(t.code,{children:"LogMessageFormatter"}),' when configuring channels. This is sometimes described as a "printer" because it controls the complete line written by the driver.']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-dart",children:"class MinimalFormatter extends LogMessageFormatter {\n  const MinimalFormatter();\n\n  @override\n  String format(Level level, String message, Context context) {\n    final requestId = context['request_id'] ?? 'n/a';\n    return '${level.name.toUpperCase()} [$requestId] $message';\n  }\n}\n\nfinal logger = await Logger.create(\n  config: const LogConfig(\n    channels: [\n      ConsoleChannel(\n        ConsoleOptions(),\n        name: 'console',\n        formatter: MinimalFormatter(),\n      ),\n    ],\n  ),\n);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Channel formatters are isolated per channel\u2014mix and match minimal text for stdout with ",(0,a.jsx)(t.code,{children:"JsonLogFormatter(prettyPrint: true)"})," for files, all while reusing the same type formatters."]}),"\n",(0,a.jsx)(t.h2,{id:"testing-and-maintenance-tips",children:"Testing and maintenance tips"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Keep formatters pure:"})," Avoid stateful operations or network calls in ",(0,a.jsx)(t.code,{children:"format"}),". Log formatting should never throw."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Prefer const constructors:"})," They allow reuse and tree shaking when possible."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Scope to feature modules:"})," Expose helper functions (e.g., ",(0,a.jsx)(t.code,{children:"registerBillingFormatters(Logger logger)"}),") to keep registration in one place."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Snapshot tests:"})," Capture formatted output in tests to prevent regressions when changing formatters."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/api/overview#type-formatters",children:"API Overview"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/advanced/middleware",children:"Middleware"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/api/drivers/daily-file",children:"Daily File Driver"})}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var r=n(6540);const a={},s=r.createContext(a);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);