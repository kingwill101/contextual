"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[525],{1745:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"api/drivers/sampling","title":"Sampling Driver","description":"Reduce log volume by routing messages through probabilistic sampling strategies.","source":"@site/docs/api/drivers/sampling.mdx","sourceDirName":"api/drivers","slug":"/api/drivers/sampling","permalink":"/contextual/api/drivers/sampling","draft":false,"unlisted":false,"editUrl":"https://github.com/kingwill101/contextual/edit/main/website/docs/api/drivers/sampling.mdx","tags":[],"version":"current","frontMatter":{"title":"Sampling Driver","description":"Reduce log volume by routing messages through probabilistic sampling strategies."},"sidebar":"docsSidebar","previous":{"title":"Stack Driver","permalink":"/contextual/api/drivers/stack"},"next":{"title":"Middleware","permalink":"/contextual/advanced/middleware"}}');var r=i(4848),a=i(8453);const s={title:"Sampling Driver",description:"Reduce log volume by routing messages through probabilistic sampling strategies."},o="Sampling Driver",t={},d=[{value:"Overview",id:"overview",level:2},{value:"Options",id:"options",level:2},{value:"Typed configuration (recommended)",id:"typed-configuration-recommended",level:2},{value:"Wrap a single destination (console)",id:"wrap-a-single-destination-console",level:3},{value:"Sample a Stack (fan\u2011out with volume control)",id:"sample-a-stack-fanout-with-volume-control",level:3},{value:"Multiple sampled variants per destination",id:"multiple-sampled-variants-per-destination",level:3},{value:"Imperative wiring (raw drivers)",id:"imperative-wiring-raw-drivers",level:2},{value:"Examples",id:"examples",level:2},{value:"Environment\u2011driven rates",id:"environmentdriven-rates",level:3},{value:"Route by intent",id:"route-by-intent",level:3},{value:"Best practices",id:"best-practices",level:2},{value:"See also",id:"see-also",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sampling-driver",children:"Sampling Driver"})}),"\n",(0,r.jsx)(n.p,{children:"Reduce log volume without losing signal. The Sampling driver probabilistically drops logs based on per-level rates and forwards retained logs to another destination. It\u2019s ideal for high\u2011volume services where debug/info logs can overwhelm storage or network bandwidth."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Wraps another channel/driver and decides whether to forward each log"}),"\n",(0,r.jsx)(n.li,{children:"Per\u2011level sampling rates (0.0\u20131.0) to control volume for each severity"}),"\n",(0,r.jsx)(n.li,{children:"Works with all other drivers (Console, Daily File, Webhook) and Stack"}),"\n",(0,r.jsx)(n.li,{children:"Configurable via typed channels or the imperative API"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"options",children:"Options"}),"\n",(0,r.jsxs)(n.p,{children:["Configure via ",(0,r.jsx)(n.code,{children:"SamplingOptions"})," (used by the typed ",(0,r.jsx)(n.code,{children:"SamplingChannel"}),"):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rates: Map<Level, double>"})," (required)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Per-level sampling rates (0.0 to 1.0). 1.0 keeps all; 0.0 drops all."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"wrappedChannel: String"})," (required)","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The name of the underlying channel to wrap and forward retained logs to."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"const options = SamplingOptions(\n  rates: {\n    Level.debug: 0.1, // keep ~10% of debug logs\n    Level.info: 1.0,  // keep all info logs\n  },\n  wrappedChannel: 'console',\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"How it works:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For each log, the driver evaluates the log ",(0,r.jsx)(n.code,{children:"Level"})," and uses the corresponding rate."]}),"\n",(0,r.jsxs)(n.li,{children:["If the random draw is within the rate, the log is forwarded to ",(0,r.jsx)(n.code,{children:"wrappedChannel"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Otherwise, the log is dropped."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Tip: Define explicit rates for the levels you care about (e.g., always 1.0 for warnings and errors)."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"typed-configuration-recommended",children:"Typed configuration (recommended)"}),"\n",(0,r.jsxs)(n.p,{children:["Use typed channels for clarity and compile\u2011time safety. Define the destination you want to wrap (e.g., ",(0,r.jsx)(n.code,{children:"console"}),"), then add a ",(0,r.jsx)(n.code,{children:"SamplingChannel"})," that references it by name."]}),"\n",(0,r.jsx)(n.h3,{id:"wrap-a-single-destination-console",children:"Wrap a single destination (console)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:contextual/contextual.dart';\n\nFuture<void> main() async {\n  final logger = await Logger.create(\n    config: LogConfig(\n      channels: const [\n        // Destination to receive kept logs\n        ConsoleChannel(\n          ConsoleOptions(),\n          name: 'console',\n        ),\n\n        // Sampled wrapper: routes to the 'console' channel\n        SamplingChannel(\n          SamplingOptions(\n            rates: {\n              Level.debug: 0.1, // keep ~10% of debug logs\n              Level.info: 1.0,  // keep all info logs\n              // define other levels as needed\n            },\n            wrappedChannel: 'console',\n          ),\n          name: 'console_sampled',\n        ),\n      ],\n    ),\n  );\n\n  // Send noisy logs through the sampled channel:\n  logger['console_sampled']?.debug('noisy diagnostic event');\n  logger['console_sampled']?.info('operational event');\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sample-a-stack-fanout-with-volume-control",children:"Sample a Stack (fan\u2011out with volume control)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final logger = await Logger.create(\n  config: LogConfig(\n    channels: const [\n      ConsoleChannel(ConsoleOptions(), name: 'console'),\n      DailyFileChannel(DailyFileOptions(path: 'logs/app'), name: 'file'),\n\n      // Fan-out to both console and file\n      StackChannel(\n        StackOptions(\n          channels: ['console', 'file'],\n          ignoreExceptions: true,\n        ),\n        name: 'stack',\n      ),\n\n      // Add a sampled variant of the stack\n      SamplingChannel(\n        SamplingOptions(\n          rates: {\n            Level.debug: 0.05, // keep ~5% of debug logs\n            Level.info: 0.5,   // keep ~50% of info logs\n            Level.warning: 1.0,\n            Level.error: 1.0,\n            Level.critical: 1.0,\n          },\n          wrappedChannel: 'stack',\n        ),\n        name: 'stack_sampled',\n      ),\n    ],\n  ),\n);\n\n// Route high-volume logs via the sampled stack:\nlogger['stack_sampled']?.debug('debug burst event');\n"})}),"\n",(0,r.jsx)(n.h3,{id:"multiple-sampled-variants-per-destination",children:"Multiple sampled variants per destination"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"final logger = await Logger.create(\n  config: LogConfig(\n    channels: const [\n      ConsoleChannel(ConsoleOptions(), name: 'console'),\n\n      // Lossy (aggressive) for very noisy telemetry\n      SamplingChannel(\n        SamplingOptions(\n          rates: { Level.debug: 0.01, Level.info: 0.25 },\n          wrappedChannel: 'console',\n        ),\n        name: 'console_lossy',\n      ),\n\n      // Lossless for anything important\n      SamplingChannel(\n        SamplingOptions(\n          rates: { Level.debug: 1.0, Level.info: 1.0 },\n          wrappedChannel: 'console',\n        ),\n        name: 'console_lossless',\n      ),\n    ],\n  ),\n);\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"imperative-wiring-raw-drivers",children:"Imperative wiring (raw drivers)"}),"\n",(0,r.jsxs)(n.p,{children:["You can also compose the driver programmatically using ",(0,r.jsx)(n.code,{children:"SamplingLogDriver"})," to wrap an existing driver instance."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"import 'package:contextual/contextual.dart';\n\nFuture<void> main() async {\n  final logger = await Logger.create();\n\n  // Destination to wrap\n  logger.addChannel('console', ConsoleLogDriver());\n\n  // Build a sampler that wraps the console driver\n  final wrapped = logger.getChannel('console')!.driver;\n\n  final sampler = SamplingLogDriver(\n    wrappedDriver: wrapped,\n    samplingRates: {\n      Level.debug: 0.1,\n      Level.info: 1.0,\n    },\n  );\n\n  logger.addChannel('console_sampled', sampler);\n\n  // Use the sampled channel\n  logger['console_sampled']?.debug('noisy event');\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"environmentdriven-rates",children:"Environment\u2011driven rates"}),"\n",(0,r.jsx)(n.p,{children:"Adjust rates per environment without code changes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"double _rate(String key, double fallback) {\n  // Pseudocode \u2013 read from env/flags/config service\n  final v = const String.fromEnvironment(key, defaultValue: '');\n  return double.tryParse(v) ?? fallback;\n}\n\nfinal logger = await Logger.create(\n  config: LogConfig(\n    channels: [\n      ConsoleChannel(ConsoleOptions(), name: 'console'),\n      SamplingChannel(\n        SamplingOptions(\n          rates: {\n            Level.debug: _rate('SAMPLE_DEBUG', 0.05),\n            Level.info: _rate('SAMPLE_INFO', 1.0),\n            // define others as needed\n          },\n          wrappedChannel: 'console',\n        ),\n        name: 'console_sampled',\n      ),\n    ],\n  ),\n);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"route-by-intent",children:"Route by intent"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"For high-volume, low-priority logs: route through a sampled channel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"logger['stack_sampled']?.debug('verbose pipeline event');\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"For important/audit logs: route through the original unsampled channel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dart",children:"logger['stack']?.error('order rejected', Context({'order_id': 'ord_123'}));\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Do not sample error/critical levels unless you fully accept data loss for those events."}),"\n",(0,r.jsx)(n.li,{children:"Be explicit: define sampling rates for all levels you care about; test the behavior with known distributions."}),"\n",(0,r.jsx)(n.li,{children:"Sample at the edge of noise: wrap only the channels or code paths producing high-volume logs."}),"\n",(0,r.jsx)(n.li,{children:"Prefer sampling lower-severity levels (debug/info); keep warnings and above at 1.0."}),"\n",(0,r.jsx)(n.li,{children:"For audit/compliance logs, avoid sampling and use durable storage (e.g., Daily File)."}),"\n",(0,r.jsx)(n.li,{children:"Validate end\u2011to\u2011end: measure ingestion/storage before and after to confirm reduction and retained signal."}),"\n",(0,r.jsx)(n.li,{children:"In tests, set all rates to 1.0 for deterministic assertions."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api/overview",children:"API Overview"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api/drivers/configuration",children:"Driver Configuration"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api/drivers/console",children:"Console Driver"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api/drivers/daily-file",children:"Daily File Driver"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api/drivers/webhook",children:"Webhook Driver"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/api/drivers/stack",children:"Stack Driver"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/advanced/batching-and-shutdown",children:"Batching & Shutdown"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var l=i(6540);const r={},a=l.createContext(r);function s(e){const n=l.useContext(a);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);